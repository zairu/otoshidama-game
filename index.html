<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>お年玉ゲーム</title>
  <style>
    body {
      margin: 0;
      overflow: hidden; /* キャンバス外のスクロールを無効にする */
    }

    canvas {
      display: block;
      margin: auto;
      background-color: #f0f0f0; /* キャンバスの背景色を指定 */
    }
  </style>
</head>
<body>

<script src="matter-js/build/matter.js"></script>
<script>
  function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  const { Engine, Runner, Body, Bodies, World, Composite, Render, Events, Mouse, MouseConstraint } = Matter;

  const engine = Engine.create();
  const runner = Runner.create();

  // ランナーの実行
  Runner.run(runner, engine);

  // 領域のサイズ
  const fieldWidth = 600;
  const fieldHeight = 600;
  const upperPadding = 100;
  const frameThickness = 20;
  const leftPadding = frameThickness;
  const rightPadding = frameThickness;
  const bottomPadding = frameThickness;
  const canvasWidth = fieldWidth + leftPadding + rightPadding;
  const canvasHeight = fieldHeight + upperPadding + bottomPadding;

  // Matter.js エンジンの描画
  const render = Render.create({
    element: document.body,
    engine: engine,
    options: {
      width: canvasWidth,
      height: canvasHeight,
      wireframes: false
    }
  });
  Render.run(render);

  // 枠の作成
  Composite.add(engine.world, [
    Bodies.rectangle(canvasWidth / 2, canvasHeight - frameThickness / 2, canvasWidth, frameThickness,
      { isStatic: true, label:"Wall" , render: { fillStyle: "red" }}),
    Bodies.rectangle(frameThickness / 2, canvasHeight / 2, frameThickness, canvasHeight,
      { isStatic: true, label:"Wall", render: { fillStyle: "red" }}),
    Bodies.rectangle(canvasWidth - frameThickness / 2, canvasHeight / 2, frameThickness, canvasHeight,
      { isStatic: true, label:"Wall", render: { fillStyle: "red" }}),
    Bodies.rectangle(canvasWidth / 2, upperPadding / 2, canvasWidth, upperPadding,
      { isStatic: true, label:"GameOverZone", isSensor: true, render: { fillStyle: "blue" }}),
  ]);

  const moneySettings = {
    yen1 : { type:"circle", radius: 20, restitution: 0.7, next: "yen5", render: { fillStyle: "red" }},
    yen5 : { type:"circle", radius: 30, restitution: 0.7, next: "yen10", render: { fillStyle: "blue" }},
    yen10: { type:"circle", radius: 40, restitution: 0.7, next: "yen50", render: { fillStyle: "yellow" }},
    yen50 : { type:"circle", radius: 50, restitution: 0.7, next: "yen100", render: { fillStyle: "purple" }},
    yen100 : { type:"circle", radius: 70, restitution: 0.7, next: "yen500", render: { fillStyle: "red" }},
    yen500: { type:"circle", radius: 90, restitution: 0.7, next: "yen1000", render: { fillStyle: "blue" }},
    yen1000: { type:"circle", radius: 110, restitution: 0.7, next: "yen2000", render: { fillStyle: "yellow" }},
    yen2000: { type:"circle", radius: 130, restitution: 0.7, next: "yen5000", render: { fillStyle: "purple" }},
    yen5000: { type:"circle", radius: 150, restitution: 0.7, next: "yen10000", render: { fillStyle: "red" }},
    yen10000: { type:"circle", radius: 170, restitution: 0.7, next: null, render: { fillStyle: "white" }},
  };

  var isGameOver = false;

  function createYen(x, y, label) {
    const setting = moneySettings[label];
    if (setting.type === "circle") {
      return Bodies.circle(x, y, setting.radius, { restitution: setting.restitution, label: label, render: setting.render });
    }
    else if (setting.type === "rectangle") {
      return Bodies.rectangle(x, y, setting.width, setting.height, { restitution: setting.restitution, label: label, render: setting.render });
    }
    return null;
  }

  function selectDropYen() {
    const table = [ "yen1", "yen5", "yen10", "yen50" ];
    return table[Math.floor(Math.random() * table.length)];
  }

  function onCollision(event) {
    if (isGameOver === true)
    {
      return;
    }

    const pairs = event.pairs;

    for (let i = 0; i < pairs.length; i++) {
      const pair = pairs[i];

      // 衝突したのが円と円の場合
      if (pair.bodyA.label === pair.bodyB.label) {
        const collisionX = (pair.bodyA.position.x + pair.bodyB.position.x) / 2;
        const collisionY = (pair.bodyA.position.y + pair.bodyB.position.y) / 2;

        const nextLabel = moneySettings[pair.bodyA.label].next;

        // 衝突したobj削除
        World.remove(engine.world, [pair.bodyA, pair.bodyB]);

        // 合成後のobj生成
        if (nextLabel != null) {
          const newYen = createYen(collisionX, collisionY, nextLabel);
          World.add(engine.world, [newYen]);
        }
      }

      // GameOver判定
      if (((pair.bodyA.label === "GameOverZone" && pair.bodyB.label !== "Wall") || (pair.bodyA.label !== "Wall" && pair.bodyB.label === "GameOverZone"))
        && (pair.bodyA.invisible !== true && pair.bodyB.invisible !== true)) {
        isGameOver = true;
        // 画面を止める
        const allBodies = Composite.allBodies(engine.world);
        allBodies.forEach(object => {
          Body.set(object, "isStatic", true);
        });
      }
    }
  }

  // Matter.js イベントハンドラの登録
  Events.on(engine, 'collisionStart', onCollision);

  // マウスとマウス制約の作成
  const mouse = Mouse.create(render.canvas);
  const mouseConstraint = MouseConstraint.create(engine, {
    mouse: mouse,
    constraint: {
      stiffness: 0,
      render: {
        visible: false
      }
    }
  });

  // マウスイベントの有効化
  World.add(engine.world, mouseConstraint);
  render.mouse = mouse;

  function clampCurrentYenX(body) {
    const setting = moneySettings[body.label];
    const left = leftPadding + setting.radius;
    const right = leftPadding + fieldWidth - setting.radius;
    const x = Math.min(Math.max(left, body.position.x), right);
    const y = body.position.y;

    Body.setPosition(body, { x: x, y: y });
  }
  var currentYen = null;

  currentYen = createYen(mouse.position.x, 20, selectDropYen());
  Body.set(currentYen, "isStatic", true);
  Body.set(currentYen, "isSensor", true);
  clampCurrentYenX(currentYen);
  World.add(engine.world, [currentYen]);

  // マウスクリック時の処理
  Events.on(mouseConstraint, 'mouseup', (event) => {
    const { mouse } = event;
    if (isGameOver === true) {
      return;
    }
    if (currentYen == null) {
      return;
    }

    const dropping = currentYen;

    // クリック位置に円を生成
    Body.set(dropping, "isStatic", false);
    Body.set(dropping, "isSensor", false);
    // ある程度落ちるまでゲームオーバー判定を無効化する
    dropping.invisible = true;

    currentYen = null;
    async function delayedExecutionAsync() {
      await delay(1000);
      if (isGameOver === true) {
        return;
      }
      dropping["invisible"] = false;

      const nextYen = createYen(mouse.position.x, 20, selectDropYen());
      Body.set(nextYen, "isStatic", true);
      Body.set(nextYen, "isSensor", true);
      clampCurrentYenX(nextYen);
      World.add(engine.world, [nextYen]);

      currentYen = nextYen;
    }

    delayedExecutionAsync();
  });

  // マウス移動時の処理
  Events.on(mouseConstraint, 'mousemove', (event) => {
    const { mouse } = event;
    if (isGameOver === true) {
      return;
    }
    if (currentYen != null) {
      Body.setPosition(currentYen, { x: mouse.position.x, y: 20 });
      clampCurrentYenX(currentYen);
    }
  });

</script>

</body>
</html>
